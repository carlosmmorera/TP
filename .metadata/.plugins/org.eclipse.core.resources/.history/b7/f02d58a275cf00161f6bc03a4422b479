package tp.pr3.ByteCode;

import java.util.Scanner;
import tp.pr3.Exception.*;

/**
 * Clase que gestiona el programa de bytecodes introducido
 * @author Carlos Moreno
 * @author Manuel Suárez
 * @version 30/12/2016
 *
 */
public class ByteCodeProgram {
	final int TAM_MAX = 100;
	/**
	 * program es un array que guarda todas las instrucciones del programa
	 * newinst guarda el número de instrucciones de las que consta el array
	 */
	private ByteCode[] program;
	int newinst;
	
	/**
	 * Constructor de la clase que inicializa el vector por defecto a 100
	 */
	public ByteCodeProgram(){
		this.program = new ByteCode[TAM_MAX];
		this.newinst = 0;
	}
	/**
	 * Método que muestra el programa almacenado
	 * @return cadena que es la representación por escrito de todas
	 * las instrucciones almacenadas en el programa
	 */
	public String toString(){
		String cadena = "\nPrograma almacenado:\n";
		
		//Recorre todo el array
		for (int i = 0; i < this.newinst; ++i){
			cadena += Integer.toString(i);
			cadena += ": " + this.program[i].toString() + '\n';
		}
		return cadena;
	}
	/**
	 * Método que inserta una nueva instrucción en el programa
	 * @param bc instrucción a insertar
	 * @throws ArrayException
	 */
	public void pushbc(ByteCode bc)throws ArrayException{
		if (this.newinst == TAM_MAX) throw new ArrayException();
		
		this.program[this.newinst] = bc;
		++this.newinst;
	}
	/**
	 * Método que reemplaza la instrucción n-ésima del programa por otra dada
	 * @param n el número de la instrucción que hay que cambiar
	 * @throws BadFormatByteCode, ArrayException
	 */
	public void replace(int n) throws BadFormatByteCode, ArrayException{
		AccesoPosicionInexistente(n);
		
		System.out.print("Nueva instruccion: ");
		
		//Pido la nueva instrucción
		Scanner entrada = new Scanner(System.in);
		String strbc = entrada.nextLine();
		
		this.program[n] = ByteCodeParser.parse(strbc);
	}
	/**
	 * Método que devuelve el tamaño del programa
	 * @return el número de instrucciones del array del programa
	 */
	public int getTam(){
		return this.newinst;
	}
	/**
	 * Método con el que se obtiene la instrucción n-ésima del programa
	 * @param n el número de la instrucción que se quiere obtener
	 *
	 * @return el ByteCode correspondiente ubicado en la posición 
	 * n-ésima en caso de que ésta 
	 * sea menor que @see {@link ByteCodeProgram#newinst}
	 * 
	 * @throws ArrayException
	 */
	public ByteCode getBcAtn(int n) throws ArrayException{
		AccesoPosicionInexistente(n);
		
		return this.program[n];
	}
	/**
	 * Método que comprueba si hay que cerrar el programa por haber llegado
	 * al final
	 * @param programCounter: el contador de programa incorporado en esta
	 * versión de la práctica
	 * @return un booleano dependiendo de si el programCounter apunta al final
	 * del programa
	 */
	public boolean cerrarPrograma(int programCounter){
		return programCounter == this.newinst;
	}
	/**
	 * Método que comprueba si se quiere acceder a una posición inexistente del programa
	 * @param pos: posición a la que se quiere acceder
	 * @throws ArrayException
	 */
	private void AccesoPosicionInexistente(int pos) throws ArrayException{
		if (pos < 0 || pos >= this.newinst) throw new ArrayException();
	}
}
