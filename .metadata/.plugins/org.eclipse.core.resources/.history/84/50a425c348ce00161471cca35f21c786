package tp.pr3.mv;

import java.util.Scanner;
import tp.pr3.ByteCode.*;
import tp.pr3.CPU.CPU;
import tp.pr3.Command.*;
import tp.pr3.Exception.*;
import tp.pr3.ProgramCompiler.*;
/**
 * Clase que gestiona la ejecución de la máquina virtual
 * @author Carlos Moreno
 * @author Manuel Suárez
 * @version 12/12/2016
 */
public class Engine {
	/**
	 * program es un objeto de tipo tp.pr2.ByteCode.ByteCodeProgram
	 * 
	 * end es un booleano que indica si se ha acabado la introducción 
	 * de instrucciones BC o no
	 */
	private SourceProgram sProgram;
	private ParsedProgram parsedProgram;
	private ByteCodeProgram bytecodeProgram;
	private boolean end;
	final static Scanner entrada = new Scanner(System.in);
	/**
	 * Constructor de la clase
	 */
	public Engine(){
		this.bytecodeProgram = new ByteCodeProgram();
		this.end = false;
	}
	
	/**
	 * Método que dirige todo el programa
	 */
	public void start(){
		String line;
		Command com;
		
		//Hasta que el usuario no ejecute "quit" no finalizará el pograma
		while(!this.end){
			try{
				System.out.print("> ");
				//Se lee el comando
				line = entrada.nextLine();
				//Se parsea
				com = CommandParser.parse(line);
				
				//Si no ha habido un error escribiendo el comando se ejecuta
				if (com != null){
					System.out.println("Comienza la ejecucion de " + com.toString()
							+ '\n');
					com.execute(this);
				}
				//Muestro mensaje de error si hubo un error en la escritura
				else System.out.println("Error: Comando incorrecto");
			}
			catch (BadFormatByteCode e){
				System.out.println(e);
			}
			catch (ArrayException e){
				System.out.println(e + "del programa"); //Si solo es para replace
			}
			finally{
				//Si el programa tiene instrucciones añadidas se muestra al usuario
				if (this.bytecodeProgram.getTam() > 0) 
					System.out.println(this.bytecodeProgram.toString());
			}
		}
		System.out.println("Fin de la ejecucion...");
	}
	/**
	 * Método que implementa el comando QUIT
	 * @return boolean dependiendo de si el comando se ejecutó con éxito
	 */
	public void quit(){ this.end = true; }
	/**
	 * Método que implementa el comando RUN
	 * @return un booleano dependiendo de si la ejecución del comando fue correcta
	 */
	public void run() throws ArrayException{
		try{
			boolean error = false;
			//Inicializo una CPU
			CPU cpu = new CPU(this.bytecodeProgram);
			error = !cpu.run();
			//Si no hubo errores muestro el estado actual de la máquina
			if (!error){
				System.out.println("El estado de la maquina tras ejecutar "
						+ "el programa es:");
				System.out.println(cpu.toString());
			}
			return !error;
		}
		catch (ArrayException e){
			System.out.println(e);
		}
	}
	/**
	 * Método que ejecuta el comando REPLACE
	 * @param rep instrucción a reemplazar
	 * @return un booleano dependiendo de 
	 * si @see {@link ByteCodeProgram#replace(int)}
	 */
	public void replace(int rep) throws BadFormatByteCode, ArrayException{ 
		this.bytecodeProgram.replace(rep);
	}
	
	public void compile() throws LexicalAnalysisException, ArrayException {
		try {
		this.lexicalAnalysis();
		this.generateByteCode();
		}
		catch (Exception e){
			
		}
	}
	public boolean cargarInstrProg(String s){
		this.sProgram.cargarInst(s);
		return true;
	}
	private void lexicalAnalysis() throws LexicalAnalysisException {
		
	}
	private void generateByteCode() throws ArrayException{
		
	}
}
