package tp.pr3.mv;

import java.util.Scanner;
import tp.pr3.ByteCode.*;
import tp.pr3.CPU.CPU;
import tp.pr3.Command.*;
import tp.pr3.Exception.*;
import tp.pr3.ProgramCompiler.*;
import tp.pr3.ProgramCompiler.Compiler;
/**
 * Clase que gestiona la ejecución de la máquina virtual.
 * @author Carlos Moreno
 * @author Manuel Suárez
 * @version 30/12/2016
 */
public class Engine {
	/**
	 * program es un objeto de tipo {@link tp.pr3.ByteCode.ByteCodeProgram}.
	 * 
	 * end es un booleano que indica si se ha acabado la introducción 
	 * de instrucciones BC o no
	 */
	private SourceProgram sProgram;
	private ParsedProgram pProgram;
	private ByteCodeProgram bytecodeProgram;
	private boolean end;
	final static Scanner entrada = new Scanner(System.in);
	/**
	 * Constructor de la clase
	 */
	public Engine(){
		this.bytecodeProgram = new ByteCodeProgram();
		this.end = false;
	}
	
	/**
	 * Método que dirige todo el programa
	 */
	public void start(){
		String line;
		Command com;
		
		//Hasta que el usuario no ejecute "quit" no finalizará el pograma
		while(!this.end){
			try{
				System.out.print("> ");
				//Se lee el comando
				line = entrada.nextLine();
				//Se parsea
				com = CommandParser.parse(line);
				
				System.out.println("Comienza la ejecucion de " + com.toString()
						+ '\n');
				com.execute(this);
			}
			catch (BadFormatByteCode e){
				System.out.println(e);
			}
			catch (ArrayException e){
				System.out.println(e);
			}
			catch (BadFormatCommand e){
				System.out.println(e);
			}
			catch(LexicalAnalysisException e){
				System.out.println(e);
			}
			finally{
				//Si el programa tiene instrucciones añadidas se muestra al usuario
				if (this.bytecodeProgram.getTam() > 0) 
					System.out.println(this.bytecodeProgram.toString());
			}
		}
		System.out.println("Fin de la ejecucion...");
	}
	/**
	 * Método que implementa el comando QUIT
	 * @return boolean dependiendo de si el comando se ejecutó con éxito
	 */
	public void quit(){ this.end = true; }
	/**
	 * Método que implementa el comando RUN
	 * @return un booleano dependiendo de si la ejecución del comando fue correcta
	 */
	public void run(){
		try{
			//Inicializo una CPU
			CPU cpu = new CPU(this.bytecodeProgram);
			cpu.run();
			System.out.println("El estado de la maquina tras ejecutar "
					+ "el programa es:");
			System.out.println(cpu.toString());
		}
		catch (ArrayException e){
			System.out.println(e);
		}
		catch(DivisionByZero e){
			System.out.println(e);
		}
		catch(StackException e){
			System.out.println(e);
		}
		catch(StackTooSmall e){
			System.out.println(e);
		}
	}
	/**
	 * Método que ejecuta el comando REPLACE
	 * @param rep instrucción a reemplazar
	 * @return un booleano dependiendo de 
	 * si @see {@link ByteCodeProgram#replace(int)}
	 */
	public void replace(int rep) throws BadFormatByteCode, ArrayException{ 
		this.bytecodeProgram.replace(rep);
	}
	/**
	 * Método que ejecuta el comando COMPILE.
	 * @throws ArrayException 
	 * @throws LexicalAnalysisException 
	 */
	public void compile() throws LexicalAnalysisException, ArrayException {
		this.lexicalAnalysis();
		this.generateByteCode();
	}
	public boolean cargarInstrProg(String s)throws ArrayException{
		this.sProgram.cargarInst(s);
		return true;
	}
	private void lexicalAnalysis() throws LexicalAnalysisException, ArrayException{
		LexicalParser lx = new LexicalParser(this.sProgram);
		lx.lexicalParser(this.pProgram, "END");
	}
	private void generateByteCode() throws ArrayException{
		Compiler compiler = new Compiler(this.bytecodeProgram);
		compiler.compile(this.pProgram);
	}
}
