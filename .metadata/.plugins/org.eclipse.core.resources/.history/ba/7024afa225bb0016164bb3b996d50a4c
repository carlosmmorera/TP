package prueba;

import java.util.Scanner;

import pruebas.ByteCode;
import pruebas.ByteCodeProgram;
import pruebas.CPU;
import pruebas.Command;
import pruebas.CommandParser;
/**
 * Clase que gestiona la ejecución de la máquina virtual
 * @author Carlos Moreno
 * @author Manuel Suárez
 * @version 17/11/2016
 *
 */
public class Engine {
	private ByteCodeProgram program;
	private boolean end;
	
	/**
	 * Constructor de la clase
	 */
	public Engine(){
		this.program = new ByteCodeProgram();
		this.end = false;
	}
	
	/**
	 * Método que dirige todo el programa
	 */
	public void start(){
		Scanner entrada = new Scanner(System.in);
		String line;
		
		Command com;
		
		//Hasta que el usuario no ejecute "quit" no finalizará el pograma
		while(!this.end){	
			System.out.print("> ");
			//Se lee el comando
			line=entrada.nextLine();
			//Se parsea
			com=CommandParser.parse(line);
			
			//Si no ha habido un error escribiendo el comando se ejecuta
			if (com != null){
				//Muestro mensaje de error si hubo un error en la ejecución
				if (!com.execute(this)) 
					System.out.println("Error: Ejecucion incorrecta del comando");
			}
			//Muestro mensaje de error si hubo un error en la escritura
			else System.out.println("Error: Comando incorrecto");
			//Si el programa tiene instrucciones añadidas se saca muestra al usuario
			if (this.program.getTam() > 0) 
				System.out.println(this.program.toString());
		}
		System.out.println("Fin de la ejecucion...");
	}
	/**
	 * Método que implementa el comando HELP
	 */
	public boolean help(){
		System.out.println("HELP: Muestra esta ayuda");
		System.out.println("QUIT: Cierra la aplicacion");
		System.out.println("RUN: Ejecuta el programa");
		System.out.println("NEWINST BYTECODE: Introduce una nueva instruccion al programa");
		System.out.println("RESET: Vacia el programa actual");
		System.out.println("REPLACE N: Reemplaza la instruccion N por la solicitada al usuario");
	
		return true;
	}
	/**
	 * Método que implementa el comando QUIT
	 */
	public boolean quit(){ this.end=true; return true; }
	/**
	 * Método que implementa el comando RUN
	 * @return un booleano dependiendo de si la ejecución fue correcta
	 */
	public boolean run(){
		/*Utilizaré el boolean error para parar la ejecución
		 * si se produjera un error en medio*/
		boolean error=false;
		//Inicializo una CPU
		CPU cpu = new CPU();
		/*Utilizo el índice para realizar todas las instrucciones
		 * El método getTam() devuelve la cantidad de instrucciones que
		 * posee el programa*/
		int indice=0, max = this.program.getTam();
		ByteCode instr;
		
		/*Hasta que no se produzca un error en mitad de la ejecución, se
		 * ejecute el bytecode HALT o hayamos ejecutado todas las instrucciones
		 * ejecutaremos lo siguiente*/
		while (!error && !cpu.getEnd() && indice < max){
			//Tomo instr como la instrucción n-ésima
			instr = this.program.instn(indice);
			//compruebo si se produce un error en la ejecución
			error = !cpu.execute(instr);
			//Aumento el índice para pasar a la siguiente instrucción
			++indice;
			if (!error) {
				//Si no hubo errores muestro el estado actual de la máquina
				System.out.println("El estado de la maquina tras ejecutar el bytecode "
						+ instr.toString() + " es:");
				System.out.println(cpu.toString());
			}
		}
		return !error;
	}
	/**
	 * Método que ejecuta el comando RESET
	 */
	public boolean resetProgram(){ this.program.reset(); return true; }
	/**
	 * Método que ejecuta el comando REPLACE
	 * @param rep
	 * @return un booleano dependiendo de 
	 * si @see {@link ByteCodeProgram#replace(int)}
	 */
	public boolean replace(int rep){ return this.program.replace(rep); }
	
	public boolean readByteCodeProgram(){
		Scanner entrada = new Scanner(System.in);
		
		String instruccion = entrada.nextLine();
		while (!instruccion.equalsIgnoreCase("END")){
			
			
			instruccion = entrada.nextLine();
		}
	}
}
